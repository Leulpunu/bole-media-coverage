{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useControlled from '@mui/utils/useControlled';\nimport useTimeout from '@mui/utils/useTimeout';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { useRtl } from '@mui/system/RtlProvider';\nimport { usePickerAdapter, usePickerTranslations } from \"../../../hooks/index.js\";\nimport { mergeDateIntoReferenceDate, getSectionsBoundaries, validateSections, getDateFromDateSections, parseSelectedSections, getLocalizedDigits, getSectionOrder } from \"./useField.utils.js\";\nimport { buildSectionsFromFormat } from \"./buildSectionsFromFormat.js\";\nimport { useValidation } from \"../../../validation/index.js\";\nimport { useControlledValue } from \"../useControlledValue.js\";\nimport { getSectionTypeGranularity } from \"../../utils/getDefaultReferenceDate.js\";\nconst QUERY_LIFE_DURATION_MS = 5000;\nexport const useFieldState = parameters => {\n  var _state$sections$state;\n  const adapter = usePickerAdapter();\n  const translations = usePickerTranslations();\n  const isRtl = useRtl();\n  const {\n    manager: {\n      validator,\n      valueType,\n      internal_valueManager: valueManager,\n      internal_fieldValueManager: fieldValueManager\n    },\n    internalPropsWithDefaults,\n    internalPropsWithDefaults: {\n      value: valueProp,\n      defaultValue,\n      referenceDate: referenceDateProp,\n      onChange,\n      format,\n      formatDensity = 'dense',\n      selectedSections: selectedSectionsProp,\n      onSelectedSectionsChange,\n      shouldRespectLeadingZeros = false,\n      timezone: timezoneProp,\n      enableAccessibleFieldDOMStructure = true\n    },\n    forwardedProps: {\n      error: errorProp\n    }\n  } = parameters;\n  const {\n    value,\n    handleValueChange,\n    timezone\n  } = useControlledValue({\n    name: 'a field component',\n    timezone: timezoneProp,\n    value: valueProp,\n    defaultValue,\n    referenceDate: referenceDateProp,\n    onChange,\n    valueManager\n  });\n  const valueRef = React.useRef(value);\n  React.useEffect(() => {\n    valueRef.current = value;\n  }, [value]);\n  const {\n    hasValidationError\n  } = useValidation({\n    props: internalPropsWithDefaults,\n    validator,\n    timezone,\n    value,\n    onError: internalPropsWithDefaults.onError\n  });\n  const localizedDigits = React.useMemo(() => getLocalizedDigits(adapter), [adapter]);\n  const sectionsValueBoundaries = React.useMemo(() => getSectionsBoundaries(adapter, localizedDigits, timezone), [adapter, localizedDigits, timezone]);\n  const getSectionsFromValue = React.useCallback(valueToAnalyze => fieldValueManager.getSectionsFromValue(valueToAnalyze, date => buildSectionsFromFormat({\n    adapter,\n    localeText: translations,\n    localizedDigits,\n    format,\n    date,\n    formatDensity,\n    shouldRespectLeadingZeros,\n    enableAccessibleFieldDOMStructure,\n    isRtl\n  })), [fieldValueManager, format, translations, localizedDigits, isRtl, shouldRespectLeadingZeros, adapter, formatDensity, enableAccessibleFieldDOMStructure]);\n  const [state, setState] = React.useState(() => {\n    const sections = getSectionsFromValue(value);\n    validateSections(sections, valueType);\n    const stateWithoutReferenceDate = {\n      sections,\n      lastExternalValue: value,\n      lastSectionsDependencies: {\n        format,\n        isRtl,\n        locale: adapter.locale\n      },\n      tempValueStrAndroid: null,\n      characterQuery: null\n    };\n    const granularity = getSectionTypeGranularity(sections);\n    const referenceValue = valueManager.getInitialReferenceValue({\n      referenceDate: referenceDateProp,\n      value,\n      adapter,\n      props: internalPropsWithDefaults,\n      granularity,\n      timezone\n    });\n    return _extends({}, stateWithoutReferenceDate, {\n      referenceValue\n    });\n  });\n  const [selectedSections, innerSetSelectedSections] = useControlled({\n    controlled: selectedSectionsProp,\n    default: null,\n    name: 'useField',\n    state: 'selectedSections'\n  });\n  const setSelectedSections = newSelectedSections => {\n    innerSetSelectedSections(newSelectedSections);\n    onSelectedSectionsChange === null || onSelectedSectionsChange === void 0 || onSelectedSectionsChange(newSelectedSections);\n  };\n  const parsedSelectedSections = React.useMemo(() => parseSelectedSections(selectedSections, state.sections), [selectedSections, state.sections]);\n  const activeSectionIndex = parsedSelectedSections === 'all' ? 0 : parsedSelectedSections;\n  const sectionOrder = React.useMemo(() => getSectionOrder(state.sections, isRtl && !enableAccessibleFieldDOMStructure), [state.sections, isRtl, enableAccessibleFieldDOMStructure]);\n  const areAllSectionsEmpty = React.useMemo(() => state.sections.every(section => section.value === ''), [state.sections]);\n\n  // When the field loses focus (no active section), consider partially filled sections as invalid.\n  // This enforces that the field must be entirely filled or entirely empty on blur.\n  const hasPartiallyFilledSectionsOnBlur = React.useMemo(() => {\n    if (activeSectionIndex != null) {\n      return false;\n    }\n    const filledSections = state.sections.filter(s => s.value !== '');\n    return filledSections.length > 0 && state.sections.length - filledSections.length > 0;\n  }, [state.sections, activeSectionIndex]);\n  const error = React.useMemo(() => {\n    if (errorProp !== undefined) {\n      return errorProp;\n    }\n    return hasValidationError || hasPartiallyFilledSectionsOnBlur;\n  }, [hasValidationError, hasPartiallyFilledSectionsOnBlur, errorProp]);\n  const publishValue = newValue => {\n    const context = {\n      validationError: validator({\n        adapter,\n        value: newValue,\n        timezone,\n        props: internalPropsWithDefaults\n      })\n    };\n    handleValueChange(newValue, context);\n  };\n  const setSectionValue = (sectionIndex, newSectionValue) => {\n    const newSections = [...state.sections];\n    newSections[sectionIndex] = _extends({}, newSections[sectionIndex], {\n      value: newSectionValue,\n      modified: true\n    });\n    return newSections;\n  };\n  const sectionToUpdateOnNextInvalidDateRef = React.useRef(null);\n  const updateSectionValueOnNextInvalidDateTimeout = useTimeout();\n  const setSectionUpdateToApplyOnNextInvalidDate = newSectionValue => {\n    if (activeSectionIndex == null) {\n      return;\n    }\n    sectionToUpdateOnNextInvalidDateRef.current = {\n      sectionIndex: activeSectionIndex,\n      value: newSectionValue\n    };\n    updateSectionValueOnNextInvalidDateTimeout.start(0, () => {\n      sectionToUpdateOnNextInvalidDateRef.current = null;\n    });\n  };\n  const clearValue = () => {\n    if (valueManager.areValuesEqual(adapter, value, valueManager.emptyValue)) {\n      setState(prevState => _extends({}, prevState, {\n        sections: prevState.sections.map(section => _extends({}, section, {\n          value: ''\n        })),\n        tempValueStrAndroid: null,\n        characterQuery: null\n      }));\n    } else {\n      setState(prevState => _extends({}, prevState, {\n        characterQuery: null\n      }));\n      publishValue(valueManager.emptyValue);\n    }\n  };\n  const clearActiveSection = () => {\n    if (activeSectionIndex == null) {\n      return;\n    }\n    const activeSection = state.sections[activeSectionIndex];\n    if (activeSection.value === '') {\n      return;\n    }\n    setSectionUpdateToApplyOnNextInvalidDate('');\n    if (fieldValueManager.getDateFromSection(value, activeSection) === null) {\n      setState(prevState => _extends({}, prevState, {\n        sections: setSectionValue(activeSectionIndex, ''),\n        tempValueStrAndroid: null,\n        characterQuery: null\n      }));\n    } else {\n      setState(prevState => _extends({}, prevState, {\n        characterQuery: null\n      }));\n      publishValue(fieldValueManager.updateDateInValue(value, activeSection, null));\n    }\n  };\n  const updateValueFromValueStr = valueStr => {\n    const parseDateStr = (dateStr, referenceDate) => {\n      const date = adapter.parse(dateStr, format);\n      if (!adapter.isValid(date)) {\n        return null;\n      }\n      const sections = buildSectionsFromFormat({\n        adapter,\n        localeText: translations,\n        localizedDigits,\n        format,\n        date,\n        formatDensity,\n        shouldRespectLeadingZeros,\n        enableAccessibleFieldDOMStructure,\n        isRtl\n      });\n      return mergeDateIntoReferenceDate(adapter, date, sections, referenceDate, false);\n    };\n    const newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);\n    publishValue(newValue);\n  };\n  const cleanActiveDateSectionsIfValueNullTimeout = useTimeout();\n  const updateSectionValue = _ref => {\n    let {\n      section,\n      newSectionValue,\n      shouldGoToNextSection\n    } = _ref;\n    updateSectionValueOnNextInvalidDateTimeout.clear();\n    cleanActiveDateSectionsIfValueNullTimeout.clear();\n    const activeDate = fieldValueManager.getDateFromSection(value, section);\n\n    /**\n     * Decide which section should be focused\n     */\n    if (shouldGoToNextSection && activeSectionIndex < state.sections.length - 1) {\n      setSelectedSections(activeSectionIndex + 1);\n    }\n\n    /**\n     * Try to build a valid date from the new section value\n     */\n    const newSections = setSectionValue(activeSectionIndex, newSectionValue);\n    const newActiveDateSections = fieldValueManager.getDateSectionsFromValue(newSections, section);\n    const newActiveDate = getDateFromDateSections(adapter, newActiveDateSections, localizedDigits);\n\n    /**\n     * If the new date is valid,\n     * Then we merge the value of the modified sections into the reference date.\n     * This makes sure that we don't lose some information of the initial date (like the time on a date field).\n     */\n    if (adapter.isValid(newActiveDate)) {\n      const mergedDate = mergeDateIntoReferenceDate(adapter, newActiveDate, newActiveDateSections, fieldValueManager.getDateFromSection(state.referenceValue, section), true);\n      if (activeDate == null) {\n        cleanActiveDateSectionsIfValueNullTimeout.start(0, () => {\n          if (valueRef.current === value) {\n            setState(prevState => _extends({}, prevState, {\n              sections: fieldValueManager.clearDateSections(state.sections, section),\n              tempValueStrAndroid: null\n            }));\n          }\n        });\n      }\n      return publishValue(fieldValueManager.updateDateInValue(value, section, mergedDate));\n    }\n\n    /**\n     * If all the sections are filled but the date is invalid and the previous date is valid or null,\n     * Then we publish an invalid date.\n     */\n    if (newActiveDateSections.every(sectionBis => sectionBis.value !== '') && (activeDate == null || adapter.isValid(activeDate))) {\n      setSectionUpdateToApplyOnNextInvalidDate(newSectionValue);\n      return publishValue(fieldValueManager.updateDateInValue(value, section, newActiveDate));\n    }\n\n    /**\n     * If the previous date is not null,\n     * Then we publish the date as `newActiveDate to prevent error state oscillation`.\n     * @link: https://github.com/mui/mui-x/issues/17967\n     */\n    if (activeDate != null) {\n      setSectionUpdateToApplyOnNextInvalidDate(newSectionValue);\n      publishValue(fieldValueManager.updateDateInValue(value, section, newActiveDate));\n    }\n\n    /**\n     * If the previous date is already null,\n     * Then we don't publish the date and we update the sections.\n     */\n    return setState(prevState => _extends({}, prevState, {\n      sections: newSections,\n      tempValueStrAndroid: null\n    }));\n  };\n  const setTempAndroidValueStr = tempValueStrAndroid => setState(prevState => _extends({}, prevState, {\n    tempValueStrAndroid\n  }));\n  const setCharacterQuery = useEventCallback(newCharacterQuery => {\n    setState(prevState => _extends({}, prevState, {\n      characterQuery: newCharacterQuery\n    }));\n  });\n\n  // If `prop.value` changes, we update the state to reflect the new value\n  if (value !== state.lastExternalValue) {\n    const isActiveDateInvalid = sectionToUpdateOnNextInvalidDateRef.current != null && !adapter.isValid(fieldValueManager.getDateFromSection(value, state.sections[sectionToUpdateOnNextInvalidDateRef.current.sectionIndex]));\n    let sections;\n    if (isActiveDateInvalid) {\n      sections = setSectionValue(sectionToUpdateOnNextInvalidDateRef.current.sectionIndex, sectionToUpdateOnNextInvalidDateRef.current.value);\n    } else {\n      sections = getSectionsFromValue(value);\n    }\n    setState(prevState => _extends({}, prevState, {\n      lastExternalValue: value,\n      sections,\n      sectionsDependencies: {\n        format,\n        isRtl,\n        locale: adapter.locale\n      },\n      referenceValue: isActiveDateInvalid ? prevState.referenceValue : fieldValueManager.updateReferenceValue(adapter, value, prevState.referenceValue),\n      tempValueStrAndroid: null\n    }));\n  }\n  if (isRtl !== state.lastSectionsDependencies.isRtl || format !== state.lastSectionsDependencies.format || adapter.locale !== state.lastSectionsDependencies.locale) {\n    const sections = getSectionsFromValue(value);\n    validateSections(sections, valueType);\n    setState(prevState => _extends({}, prevState, {\n      lastSectionsDependencies: {\n        format,\n        isRtl,\n        locale: adapter.locale\n      },\n      sections,\n      tempValueStrAndroid: null,\n      characterQuery: null\n    }));\n  }\n  if (state.characterQuery != null && !error && activeSectionIndex == null) {\n    setCharacterQuery(null);\n  }\n  if (state.characterQuery != null && ((_state$sections$state = state.sections[state.characterQuery.sectionIndex]) === null || _state$sections$state === void 0 ? void 0 : _state$sections$state.type) !== state.characterQuery.sectionType) {\n    setCharacterQuery(null);\n  }\n  React.useEffect(() => {\n    if (sectionToUpdateOnNextInvalidDateRef.current != null) {\n      sectionToUpdateOnNextInvalidDateRef.current = null;\n    }\n  });\n  const cleanCharacterQueryTimeout = useTimeout();\n  React.useEffect(() => {\n    if (state.characterQuery != null) {\n      cleanCharacterQueryTimeout.start(QUERY_LIFE_DURATION_MS, () => setCharacterQuery(null));\n    }\n    return () => {};\n  }, [state.characterQuery, setCharacterQuery, cleanCharacterQueryTimeout]);\n\n  // If `tempValueStrAndroid` is still defined for some section when running `useEffect`,\n  // Then `onChange` has only been called once, which means the user pressed `Backspace` to reset the section.\n  // This causes a small flickering on Android,\n  // But we can't use `useEnhancedEffect` which is always called before the second `onChange` call and then would cause false positives.\n  React.useEffect(() => {\n    if (state.tempValueStrAndroid != null && activeSectionIndex != null) {\n      clearActiveSection();\n    }\n  }, [state.sections]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    // States and derived states\n    activeSectionIndex,\n    areAllSectionsEmpty,\n    error,\n    localizedDigits,\n    parsedSelectedSections,\n    sectionOrder,\n    sectionsValueBoundaries,\n    state,\n    timezone,\n    value,\n    // Methods to update the states\n    clearValue,\n    clearActiveSection,\n    setCharacterQuery,\n    setSelectedSections,\n    setTempAndroidValueStr,\n    updateSectionValue,\n    updateValueFromValueStr,\n    // Utilities methods\n    getSectionsFromValue\n  };\n};","map":{"version":3,"names":["_extends","React","useControlled","useTimeout","useEventCallback","useRtl","usePickerAdapter","usePickerTranslations","mergeDateIntoReferenceDate","getSectionsBoundaries","validateSections","getDateFromDateSections","parseSelectedSections","getLocalizedDigits","getSectionOrder","buildSectionsFromFormat","useValidation","useControlledValue","getSectionTypeGranularity","QUERY_LIFE_DURATION_MS","useFieldState","parameters","_state$sections$state","adapter","translations","isRtl","manager","validator","valueType","internal_valueManager","valueManager","internal_fieldValueManager","fieldValueManager","internalPropsWithDefaults","value","valueProp","defaultValue","referenceDate","referenceDateProp","onChange","format","formatDensity","selectedSections","selectedSectionsProp","onSelectedSectionsChange","shouldRespectLeadingZeros","timezone","timezoneProp","enableAccessibleFieldDOMStructure","forwardedProps","error","errorProp","handleValueChange","name","valueRef","useRef","useEffect","current","hasValidationError","props","onError","localizedDigits","useMemo","sectionsValueBoundaries","getSectionsFromValue","useCallback","valueToAnalyze","date","localeText","state","setState","useState","sections","stateWithoutReferenceDate","lastExternalValue","lastSectionsDependencies","locale","tempValueStrAndroid","characterQuery","granularity","referenceValue","getInitialReferenceValue","innerSetSelectedSections","controlled","default","setSelectedSections","newSelectedSections","parsedSelectedSections","activeSectionIndex","sectionOrder","areAllSectionsEmpty","every","section","hasPartiallyFilledSectionsOnBlur","filledSections","filter","s","length","undefined","publishValue","newValue","context","validationError","setSectionValue","sectionIndex","newSectionValue","newSections","modified","sectionToUpdateOnNextInvalidDateRef","updateSectionValueOnNextInvalidDateTimeout","setSectionUpdateToApplyOnNextInvalidDate","start","clearValue","areValuesEqual","emptyValue","prevState","map","clearActiveSection","activeSection","getDateFromSection","updateDateInValue","updateValueFromValueStr","valueStr","parseDateStr","dateStr","parse","isValid","parseValueStr","cleanActiveDateSectionsIfValueNullTimeout","updateSectionValue","_ref","shouldGoToNextSection","clear","activeDate","newActiveDateSections","getDateSectionsFromValue","newActiveDate","mergedDate","clearDateSections","sectionBis","setTempAndroidValueStr","setCharacterQuery","newCharacterQuery","isActiveDateInvalid","sectionsDependencies","updateReferenceValue","type","sectionType","cleanCharacterQueryTimeout"],"sources":["D:/requset delivery/bole-media-coverage/node_modules/@mui/x-date-pickers/esm/internals/hooks/useField/useFieldState.js"],"sourcesContent":["'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useControlled from '@mui/utils/useControlled';\nimport useTimeout from '@mui/utils/useTimeout';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { useRtl } from '@mui/system/RtlProvider';\nimport { usePickerAdapter, usePickerTranslations } from \"../../../hooks/index.js\";\nimport { mergeDateIntoReferenceDate, getSectionsBoundaries, validateSections, getDateFromDateSections, parseSelectedSections, getLocalizedDigits, getSectionOrder } from \"./useField.utils.js\";\nimport { buildSectionsFromFormat } from \"./buildSectionsFromFormat.js\";\nimport { useValidation } from \"../../../validation/index.js\";\nimport { useControlledValue } from \"../useControlledValue.js\";\nimport { getSectionTypeGranularity } from \"../../utils/getDefaultReferenceDate.js\";\nconst QUERY_LIFE_DURATION_MS = 5000;\nexport const useFieldState = parameters => {\n  const adapter = usePickerAdapter();\n  const translations = usePickerTranslations();\n  const isRtl = useRtl();\n  const {\n    manager: {\n      validator,\n      valueType,\n      internal_valueManager: valueManager,\n      internal_fieldValueManager: fieldValueManager\n    },\n    internalPropsWithDefaults,\n    internalPropsWithDefaults: {\n      value: valueProp,\n      defaultValue,\n      referenceDate: referenceDateProp,\n      onChange,\n      format,\n      formatDensity = 'dense',\n      selectedSections: selectedSectionsProp,\n      onSelectedSectionsChange,\n      shouldRespectLeadingZeros = false,\n      timezone: timezoneProp,\n      enableAccessibleFieldDOMStructure = true\n    },\n    forwardedProps: {\n      error: errorProp\n    }\n  } = parameters;\n  const {\n    value,\n    handleValueChange,\n    timezone\n  } = useControlledValue({\n    name: 'a field component',\n    timezone: timezoneProp,\n    value: valueProp,\n    defaultValue,\n    referenceDate: referenceDateProp,\n    onChange,\n    valueManager\n  });\n  const valueRef = React.useRef(value);\n  React.useEffect(() => {\n    valueRef.current = value;\n  }, [value]);\n  const {\n    hasValidationError\n  } = useValidation({\n    props: internalPropsWithDefaults,\n    validator,\n    timezone,\n    value,\n    onError: internalPropsWithDefaults.onError\n  });\n  const localizedDigits = React.useMemo(() => getLocalizedDigits(adapter), [adapter]);\n  const sectionsValueBoundaries = React.useMemo(() => getSectionsBoundaries(adapter, localizedDigits, timezone), [adapter, localizedDigits, timezone]);\n  const getSectionsFromValue = React.useCallback(valueToAnalyze => fieldValueManager.getSectionsFromValue(valueToAnalyze, date => buildSectionsFromFormat({\n    adapter,\n    localeText: translations,\n    localizedDigits,\n    format,\n    date,\n    formatDensity,\n    shouldRespectLeadingZeros,\n    enableAccessibleFieldDOMStructure,\n    isRtl\n  })), [fieldValueManager, format, translations, localizedDigits, isRtl, shouldRespectLeadingZeros, adapter, formatDensity, enableAccessibleFieldDOMStructure]);\n  const [state, setState] = React.useState(() => {\n    const sections = getSectionsFromValue(value);\n    validateSections(sections, valueType);\n    const stateWithoutReferenceDate = {\n      sections,\n      lastExternalValue: value,\n      lastSectionsDependencies: {\n        format,\n        isRtl,\n        locale: adapter.locale\n      },\n      tempValueStrAndroid: null,\n      characterQuery: null\n    };\n    const granularity = getSectionTypeGranularity(sections);\n    const referenceValue = valueManager.getInitialReferenceValue({\n      referenceDate: referenceDateProp,\n      value,\n      adapter,\n      props: internalPropsWithDefaults,\n      granularity,\n      timezone\n    });\n    return _extends({}, stateWithoutReferenceDate, {\n      referenceValue\n    });\n  });\n  const [selectedSections, innerSetSelectedSections] = useControlled({\n    controlled: selectedSectionsProp,\n    default: null,\n    name: 'useField',\n    state: 'selectedSections'\n  });\n  const setSelectedSections = newSelectedSections => {\n    innerSetSelectedSections(newSelectedSections);\n    onSelectedSectionsChange?.(newSelectedSections);\n  };\n  const parsedSelectedSections = React.useMemo(() => parseSelectedSections(selectedSections, state.sections), [selectedSections, state.sections]);\n  const activeSectionIndex = parsedSelectedSections === 'all' ? 0 : parsedSelectedSections;\n  const sectionOrder = React.useMemo(() => getSectionOrder(state.sections, isRtl && !enableAccessibleFieldDOMStructure), [state.sections, isRtl, enableAccessibleFieldDOMStructure]);\n  const areAllSectionsEmpty = React.useMemo(() => state.sections.every(section => section.value === ''), [state.sections]);\n\n  // When the field loses focus (no active section), consider partially filled sections as invalid.\n  // This enforces that the field must be entirely filled or entirely empty on blur.\n  const hasPartiallyFilledSectionsOnBlur = React.useMemo(() => {\n    if (activeSectionIndex != null) {\n      return false;\n    }\n    const filledSections = state.sections.filter(s => s.value !== '');\n    return filledSections.length > 0 && state.sections.length - filledSections.length > 0;\n  }, [state.sections, activeSectionIndex]);\n  const error = React.useMemo(() => {\n    if (errorProp !== undefined) {\n      return errorProp;\n    }\n    return hasValidationError || hasPartiallyFilledSectionsOnBlur;\n  }, [hasValidationError, hasPartiallyFilledSectionsOnBlur, errorProp]);\n  const publishValue = newValue => {\n    const context = {\n      validationError: validator({\n        adapter,\n        value: newValue,\n        timezone,\n        props: internalPropsWithDefaults\n      })\n    };\n    handleValueChange(newValue, context);\n  };\n  const setSectionValue = (sectionIndex, newSectionValue) => {\n    const newSections = [...state.sections];\n    newSections[sectionIndex] = _extends({}, newSections[sectionIndex], {\n      value: newSectionValue,\n      modified: true\n    });\n    return newSections;\n  };\n  const sectionToUpdateOnNextInvalidDateRef = React.useRef(null);\n  const updateSectionValueOnNextInvalidDateTimeout = useTimeout();\n  const setSectionUpdateToApplyOnNextInvalidDate = newSectionValue => {\n    if (activeSectionIndex == null) {\n      return;\n    }\n    sectionToUpdateOnNextInvalidDateRef.current = {\n      sectionIndex: activeSectionIndex,\n      value: newSectionValue\n    };\n    updateSectionValueOnNextInvalidDateTimeout.start(0, () => {\n      sectionToUpdateOnNextInvalidDateRef.current = null;\n    });\n  };\n  const clearValue = () => {\n    if (valueManager.areValuesEqual(adapter, value, valueManager.emptyValue)) {\n      setState(prevState => _extends({}, prevState, {\n        sections: prevState.sections.map(section => _extends({}, section, {\n          value: ''\n        })),\n        tempValueStrAndroid: null,\n        characterQuery: null\n      }));\n    } else {\n      setState(prevState => _extends({}, prevState, {\n        characterQuery: null\n      }));\n      publishValue(valueManager.emptyValue);\n    }\n  };\n  const clearActiveSection = () => {\n    if (activeSectionIndex == null) {\n      return;\n    }\n    const activeSection = state.sections[activeSectionIndex];\n    if (activeSection.value === '') {\n      return;\n    }\n    setSectionUpdateToApplyOnNextInvalidDate('');\n    if (fieldValueManager.getDateFromSection(value, activeSection) === null) {\n      setState(prevState => _extends({}, prevState, {\n        sections: setSectionValue(activeSectionIndex, ''),\n        tempValueStrAndroid: null,\n        characterQuery: null\n      }));\n    } else {\n      setState(prevState => _extends({}, prevState, {\n        characterQuery: null\n      }));\n      publishValue(fieldValueManager.updateDateInValue(value, activeSection, null));\n    }\n  };\n  const updateValueFromValueStr = valueStr => {\n    const parseDateStr = (dateStr, referenceDate) => {\n      const date = adapter.parse(dateStr, format);\n      if (!adapter.isValid(date)) {\n        return null;\n      }\n      const sections = buildSectionsFromFormat({\n        adapter,\n        localeText: translations,\n        localizedDigits,\n        format,\n        date,\n        formatDensity,\n        shouldRespectLeadingZeros,\n        enableAccessibleFieldDOMStructure,\n        isRtl\n      });\n      return mergeDateIntoReferenceDate(adapter, date, sections, referenceDate, false);\n    };\n    const newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);\n    publishValue(newValue);\n  };\n  const cleanActiveDateSectionsIfValueNullTimeout = useTimeout();\n  const updateSectionValue = ({\n    section,\n    newSectionValue,\n    shouldGoToNextSection\n  }) => {\n    updateSectionValueOnNextInvalidDateTimeout.clear();\n    cleanActiveDateSectionsIfValueNullTimeout.clear();\n    const activeDate = fieldValueManager.getDateFromSection(value, section);\n\n    /**\n     * Decide which section should be focused\n     */\n    if (shouldGoToNextSection && activeSectionIndex < state.sections.length - 1) {\n      setSelectedSections(activeSectionIndex + 1);\n    }\n\n    /**\n     * Try to build a valid date from the new section value\n     */\n    const newSections = setSectionValue(activeSectionIndex, newSectionValue);\n    const newActiveDateSections = fieldValueManager.getDateSectionsFromValue(newSections, section);\n    const newActiveDate = getDateFromDateSections(adapter, newActiveDateSections, localizedDigits);\n\n    /**\n     * If the new date is valid,\n     * Then we merge the value of the modified sections into the reference date.\n     * This makes sure that we don't lose some information of the initial date (like the time on a date field).\n     */\n    if (adapter.isValid(newActiveDate)) {\n      const mergedDate = mergeDateIntoReferenceDate(adapter, newActiveDate, newActiveDateSections, fieldValueManager.getDateFromSection(state.referenceValue, section), true);\n      if (activeDate == null) {\n        cleanActiveDateSectionsIfValueNullTimeout.start(0, () => {\n          if (valueRef.current === value) {\n            setState(prevState => _extends({}, prevState, {\n              sections: fieldValueManager.clearDateSections(state.sections, section),\n              tempValueStrAndroid: null\n            }));\n          }\n        });\n      }\n      return publishValue(fieldValueManager.updateDateInValue(value, section, mergedDate));\n    }\n\n    /**\n     * If all the sections are filled but the date is invalid and the previous date is valid or null,\n     * Then we publish an invalid date.\n     */\n    if (newActiveDateSections.every(sectionBis => sectionBis.value !== '') && (activeDate == null || adapter.isValid(activeDate))) {\n      setSectionUpdateToApplyOnNextInvalidDate(newSectionValue);\n      return publishValue(fieldValueManager.updateDateInValue(value, section, newActiveDate));\n    }\n\n    /**\n     * If the previous date is not null,\n     * Then we publish the date as `newActiveDate to prevent error state oscillation`.\n     * @link: https://github.com/mui/mui-x/issues/17967\n     */\n    if (activeDate != null) {\n      setSectionUpdateToApplyOnNextInvalidDate(newSectionValue);\n      publishValue(fieldValueManager.updateDateInValue(value, section, newActiveDate));\n    }\n\n    /**\n     * If the previous date is already null,\n     * Then we don't publish the date and we update the sections.\n     */\n    return setState(prevState => _extends({}, prevState, {\n      sections: newSections,\n      tempValueStrAndroid: null\n    }));\n  };\n  const setTempAndroidValueStr = tempValueStrAndroid => setState(prevState => _extends({}, prevState, {\n    tempValueStrAndroid\n  }));\n  const setCharacterQuery = useEventCallback(newCharacterQuery => {\n    setState(prevState => _extends({}, prevState, {\n      characterQuery: newCharacterQuery\n    }));\n  });\n\n  // If `prop.value` changes, we update the state to reflect the new value\n  if (value !== state.lastExternalValue) {\n    const isActiveDateInvalid = sectionToUpdateOnNextInvalidDateRef.current != null && !adapter.isValid(fieldValueManager.getDateFromSection(value, state.sections[sectionToUpdateOnNextInvalidDateRef.current.sectionIndex]));\n    let sections;\n    if (isActiveDateInvalid) {\n      sections = setSectionValue(sectionToUpdateOnNextInvalidDateRef.current.sectionIndex, sectionToUpdateOnNextInvalidDateRef.current.value);\n    } else {\n      sections = getSectionsFromValue(value);\n    }\n    setState(prevState => _extends({}, prevState, {\n      lastExternalValue: value,\n      sections,\n      sectionsDependencies: {\n        format,\n        isRtl,\n        locale: adapter.locale\n      },\n      referenceValue: isActiveDateInvalid ? prevState.referenceValue : fieldValueManager.updateReferenceValue(adapter, value, prevState.referenceValue),\n      tempValueStrAndroid: null\n    }));\n  }\n  if (isRtl !== state.lastSectionsDependencies.isRtl || format !== state.lastSectionsDependencies.format || adapter.locale !== state.lastSectionsDependencies.locale) {\n    const sections = getSectionsFromValue(value);\n    validateSections(sections, valueType);\n    setState(prevState => _extends({}, prevState, {\n      lastSectionsDependencies: {\n        format,\n        isRtl,\n        locale: adapter.locale\n      },\n      sections,\n      tempValueStrAndroid: null,\n      characterQuery: null\n    }));\n  }\n  if (state.characterQuery != null && !error && activeSectionIndex == null) {\n    setCharacterQuery(null);\n  }\n  if (state.characterQuery != null && state.sections[state.characterQuery.sectionIndex]?.type !== state.characterQuery.sectionType) {\n    setCharacterQuery(null);\n  }\n  React.useEffect(() => {\n    if (sectionToUpdateOnNextInvalidDateRef.current != null) {\n      sectionToUpdateOnNextInvalidDateRef.current = null;\n    }\n  });\n  const cleanCharacterQueryTimeout = useTimeout();\n  React.useEffect(() => {\n    if (state.characterQuery != null) {\n      cleanCharacterQueryTimeout.start(QUERY_LIFE_DURATION_MS, () => setCharacterQuery(null));\n    }\n    return () => {};\n  }, [state.characterQuery, setCharacterQuery, cleanCharacterQueryTimeout]);\n\n  // If `tempValueStrAndroid` is still defined for some section when running `useEffect`,\n  // Then `onChange` has only been called once, which means the user pressed `Backspace` to reset the section.\n  // This causes a small flickering on Android,\n  // But we can't use `useEnhancedEffect` which is always called before the second `onChange` call and then would cause false positives.\n  React.useEffect(() => {\n    if (state.tempValueStrAndroid != null && activeSectionIndex != null) {\n      clearActiveSection();\n    }\n  }, [state.sections]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    // States and derived states\n    activeSectionIndex,\n    areAllSectionsEmpty,\n    error,\n    localizedDigits,\n    parsedSelectedSections,\n    sectionOrder,\n    sectionsValueBoundaries,\n    state,\n    timezone,\n    value,\n    // Methods to update the states\n    clearValue,\n    clearActiveSection,\n    setCharacterQuery,\n    setSelectedSections,\n    setTempAndroidValueStr,\n    updateSectionValue,\n    updateValueFromValueStr,\n    // Utilities methods\n    getSectionsFromValue\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}